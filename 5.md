````Golang
func identifyPalindrome(s string) (bool, int) {
	num := len(s) / 2
	for i := 0; i < num; i++ {
		if s[i] != s[len(s)-i-1] {
			return false, i
		}
	}
	return true, 0
}

func longestPalindrome(s string) string {
	if len(s) <= 1 {
		return s
	}

	var start, end, maxIdx, offs int
	var lastPos, lastEnd int
	var charMap [256]int

	charMap[int(s[start])] = start
	maxLen := 1
	for end < len(s) {
		if start == end {
			end++
			continue
		}

		var ok, found bool
		pos := charMap[int(s[end])]
		if s[pos] == s[end] {
			ok = true
		}
		//the pos must be in the current range
		if ok && pos >= start {
			found, offs = identifyPalindrome(s[pos : end+1])
			//only move start if the sub-string not palindrome
			//or we may be missing the longer match, just be greedy
			if !found {
				start = pos + offs
				if start >= len(s) {
					break
				}
				charMap[int(s[end])] = end
			}
		} else {
			charMap[int(s[end])] = end
		}
		end++

		if found {
			curLen := end - start
			if pos > start {
				curLen = end - pos
			}
			if curLen > maxLen {
				maxLen = curLen
				maxIdx = start
				lastPos = pos
				lastEnd = end
			}
		}
	}

	if lastPos > start {
		maxIdx = lastPos
		maxLen = lastEnd - lastPos
	}
	return s[maxIdx : maxIdx+maxLen]
}
```
